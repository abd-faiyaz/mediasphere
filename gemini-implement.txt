7. Setting Up Google Gemini With Spring: Step-by-Step Guide
Step 1: Get Your Gemini API Key

Visit the Google AI Studio website
Sign in with your Google account
Click “Get API key”
A new page will open where you’ll find the ‘Create API Key’ option to generate your API key
Copy and securely store your API key
Step 2: Add Spring AI Dependencies to Your Project

Set up a Spring Boot project with the necessary dependencies in pom.xml:

<
dependencies
>
    
<
dependency
>
        
<
groupId
>org.springframework.boot</
groupId
>
        
<
artifactId
>spring-boot-starter-web</
artifactId
>
    
</
dependency
>
    
<
dependency
>
        
<
groupId
>org.springframework.ai</
groupId
>
        
<
artifactId
>spring-ai-starter-model-openai</
artifactId
>
    
</
dependency
>
</
dependencies
>

<
dependencyManagement
>
    
<
dependencies
>
        
<
dependency
>
            
<
groupId
>org.springframework.ai</
groupId
>
            
<
artifactId
>spring-ai-bom</
artifactId
>
            
<
version
>${spring-ai.version}</
version
>
            
<
type
>pom</
type
>
            
<
scope
>import</
scope
>
        
</
dependency
>
    
</
dependencies
>
</
dependencyManagement
>
pom.xml

These dependencies provide:

spring-boot-starter-web: Basic web application functionality for creating REST endpoints
spring-ai-starter-model-openai: This starter simplifies the integration of AI features into your Spring Boot application. It leverages OpenAI compatibility, which, in our case, lets you interact with Google Gemini’s free AI models using the same familiar APIs.
spring-ai-bom: The dependencyManagement section uses Spring AI’s Bill of Materials (BOM) to ensure compatibility between Spring AI components.
Step 3: Configure Application Properties

Open your application.yml file and add the following configurations, replacing <your-gemini-api-key> with the API key you obtained in the step 1:

logging
:
level
:
io
:
modelcontextprotocol
:
client
: 
DEBUG
spec
: 
DEBUG

spring
:
application
:
name
: 
spring-boot-ai-gemini-integration
ai
:
openai
:
api-key
: 
"<your-gemini-api-key>"
base-url
: 
https://generativelanguage.googleapis.com/v1beta/openai
chat
:
completions-path
: 
/chat/completions
options
:
model
: 
gemini-2.0-flash-exp
application.yaml

We are setting the base-url to https://generativelanguage.googleapis.com/v1beta/openai, which is the endpoint for the Gemini API with OpenAI compatibility.
The chat.completions-path is set to /chat/completions, aligning with the OpenAI API structure.
Under chat.options.model, you can specify the Gemini model you want to use. Experiment with gemini-2.5-pro-exp-03-25 and gemini-2.0-flash-exp (or other available free models).


Step 4: Creating the ChatClient Configuration

To interact with Google Gemini in a Spring Boot application, you need to configure a chat client using Spring AI. This client enables seamless communication with the AI model, allowing you to send prompts and receive responses dynamically.

Below is the configuration for a basic chat client:

import
org
.springframework
.ai
.chat
.client
.ChatClient
;
import
org
.springframework
.ai
.tool
.ToolCallbackProvider
;
import
org
.springframework
.context
.annotation
.Bean
;
import
org
.springframework
.context
.annotation
.Configuration
;

@
Configuration
public
class
ChatClientConfig
 {
    @
Bean
public
ChatClient
chatClient
(
ChatClient
.
Builder
chatClientBuilder
) {
return
chatClientBuilder
.
build
();
    }
}
ChatClientConfig.java

Explanation:

This configuration registers a ChatClient as a Spring Bean. The ChatClient.Builder is used to create an instance of the client, which can then be used in the application to send queries and receive responses from Google Gemini. This setup ensures that AI interactions are handled efficiently within the Spring Boot framework.

Step 5: Building a Controller

Let’s create a simple REST controller to interact with the configured Gemini model for basic chat:

import
org.springframework.ai.chat.client.ChatClient
;
import
org.springframework.beans.factory.annotation.Autowired
;
import
org.springframework.web.bind.annotation.PostMapping
;
import
org.springframework.web.bind.annotation.RequestBody
;
import
org.springframework.web.bind.annotation.RequestMapping
;
import
org.springframework.web.bind.annotation.RestController
;

@
RestController
@
RequestMapping
(
"/chat"
)
public
class
ChatController
{

private
final
ChatClient
chatClient
;

    
@
Autowired
public
ChatController
(
ChatClient
chatClient
) {
this
.
chatClient
=
 chatClient;
    }

    
@
PostMapping
(
"/ask"
)
public
String
chat
(@
RequestBody
String
userInput
) {
return
chatClient
.
prompt
(userInput).
call
().
content
();
    }
}
ChatController.java

Our controller:

Exposes a /chat/ask endpoint that accepts POST requests
Takes the user’s input as the request body
Then it calls prompt() on the ChatClient, which processes the input and returns the final response.
Returns the model’s response as a string
When you send a POST request, the controller will forward your message to the Gemini API and return the response.



Step 6: Testing the Implementation

Now, you can run your Spring Boot application and send a POST request to /chat/ask with a body containing your question as a string. The response will be the Gemini model’s answer.

Example: Understanding “Spring AI” with Google Gemini

Let’s say we want to understand what Spring AI is. We can send a POST request to our /chat/ask endpoint, and the chat client will forward our query to the Google Gemini LLM, returning an AI-generated response.